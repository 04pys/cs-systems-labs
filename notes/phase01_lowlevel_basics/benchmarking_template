# 성능 측정 메모: template 벤치마크 프레임 + spot_check 검증

## 내가 template 벤치마크 프레임을 쓴 이유
여러 구현을 비교하려고 벤치마크 코드를 매번 새로 만들면 금방 지저분해지고, 복붙하다가 실수하기 쉬움.  
그래서 bench 같은 공통 함수를 하나 만들어두고, 실험 대상만 바꿔서 돌리는 방식으로 정리했음.

bench는 내부에서 시간을 재고, 결과를 출력하고, 필요하면 검증까지 함.  
그리고 실제로 실험하고 싶은 부분은 fn 하나로 받아서 `fn()`만 실행하는 구조임.  
이걸 람다로 넘기니까 코드가 훨씬 보기 편했고, 실험을 바꿔 끼우기도 쉬웠음.

람다는 그냥 짧게 말하면 이름 없는 함수임.  
특히 외부 변수(A, B, N, B 같은 실험 파라미터)를 캡처할 수 있어서, 함수 인자를 길게 늘리지 않아도 됨.

예를 들면 이런 식으로 실험을 바꿔가며 돌릴 수 있었음.
- `bench(..., [&]{ naive(A,B,N); })`
- `bench(..., [&]{ tiled(A,B,N,Bs); })`

새 실험을 추가할 때도 같은 패턴을 그대로 재사용하면 됨.

---

## 성능 측정에서 검증이 필요한 이유
성능만 재면, 코드가 틀렸는데도 시간이 빨라 보이는 상황이 생길 수 있음.  
예를 들어 인덱스를 하나 빼먹어서 실제로는 일을 덜 하게 되면 측정값은 좋아지지만, 그건 제대로 된 비교가 아님.  
그래서 측정 전에 결과가 맞는지 확인하는 장치를 넣는 게 안전했음.

---

## spot_check로 전치가 맞는지 확인한 방법
전치를 완전 검증하려면 N×N 전체를 다 비교해야 하는데, N이 커지면 그 검증 자체가 너무 오래 걸려서 측정을 망칠 수 있음.  
그래서 무작위로 몇 개 좌표만 뽑아서 맞는지 확인하는 spot_check를 썼음.

전치가 맞다면 항상 아래가 성립해야 함.
- `B[j, i] == A[i, j]`
즉 1D로는
- `B[j*N + i] == A[i*N + j]`

spot_check는 난수로 (i, j)를 몇 번 뽑고, 저 조건이 맞는지 확인함.  
한 번이라도 틀리면 false를 반환하고, 다 맞으면 true임.

난수 시드를 고정해두면 매번 같은 좌표를 검사하게 되어서, 버그가 생겼을 때 재현이 쉬움.

---

## A를 패턴으로 채운 이유
A를 전부 1로 채우면 전치가 틀려도 결과가 얼핏 맞아 보일 수 있음.  
그래서 좌표마다 값이 다르게 들어가도록 패턴을 넣었음.

방법은 대충 큰 수를 곱해서 섞고(mod 같은 걸로) 범위를 줄이는 방식이었음.  
이렇게 해두면 (i, j)마다 값이 달라서, spot_check가 인덱싱 실수를 더 잘 잡아줌.

---

## 다음 실험에 그대로 가져갈 체크리스트
- bench 같은 공통 측정 프레임을 하나 두고, 실험 대상은 람다로 바꿔 끼우기  
- 측정 전에 spot_check로 결과가 맞는지 먼저 확인하기  
- 입력은 단순한 상수로 채우지 말고 위치마다 다른 패턴을 쓰기  
- Colab처럼 환경이 흔들릴 수 있으면 여러 번 돌려서 경향을 보기  
