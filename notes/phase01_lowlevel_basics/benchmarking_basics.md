# Benchmarking basics (lab01~lab02)

## 1) What a microbenchmark is
마이크로벤치마크는 “아주 작은 코드 조각”의 성능을 재서 병목 요인을 관찰하는 실험임.  
목표는 절대값이 아니라 **패턴/조건 변화에 따른 상대 비교**를 얻는 것임.

## 2) Warmup을 하는 이유
첫 실행은 캐시가 비어 있고, 페이지 폴트/동적 로딩/CPU 주파수 변화 등으로 흔들릴 수 있음.  
그래서 워밍업 1회(또는 몇 회)를 따로 돌리고, 그 다음 측정값을 비교하는 것이 안전함.

## 3) 컴파일러 최적화로 “측정 루프가 사라지는” 문제
최적화(-O2 등)에서 결과가 관측되지 않으면, 컴파일러가 루프를 제거할 수 있음.  
이를 막기 위해 `volatile` 변수에 누적하거나, 출력/observable effect를 만들고, 합(sum)을 함께 출력하는 방식이 자주 사용됨.

## 4) 조건 고정이 핵심
실험을 비교할 때는 아래를 최대한 고정함.
- 동일한 컴파일 옵션(-O2, -std=c++17 등)
- 동일한 입력 크기(N), 동일한 코드 경로
- 동일한 실행 환경(가능하면 같은 세션/같은 런타임)

## 5) 변동성(특히 Colab) 다루기
Colab/공유 환경은 실행 중 시스템 부하가 바뀔 수 있어 시간 변동이 큼.  
가능하면 동일 케이스를 여러 번 반복 실행해서 “대략적인 경향”을 확인하는 방식이 더 신뢰도 높음.

## 6) 결과 해석의 우선순위
- 단일 수치보다 **경향(trend)**을 먼저 봄 (예: B가 커질수록 개선되다가 다시 악화)
- sum이 동일한지 확인해 “동일 작업을 측정했는지” 검증함
- 의미 있는 차이는 보통 수 배(×2 이상)에서 더 확실함(환경 변동보다 큼)

## 7) 이번 labs에 적용한 체크리스트
- warmup 실행 후 측정함
- `volatile sum`으로 루프 제거를 방지함
- 같은 N에서 row/col/tiled를 비교해 접근 패턴의 영향만 보려 했음
- B를 스윕하여 최적점이 생기는지 확인함
