# Block size B & Working set (lab02)

## Working set 개념
Working set은 “짧은 시간 구간에서 동시에 필요로 하는 데이터의 규모”임  
캐시는 working set이 작고 재사용이 많을수록 유리함

## 타일 1개가 대략 건드리는 데이터 규모
int가 4B라고 하면, BxB 타일의 원소 수는 B^2개임  
- 대략적인 데이터 크기: B^2 * 4 bytes

예시(대략치):
- B=16  → 256 ints → 1KB
- B=32  → 1024 ints → 4KB
- B=64  → 4096 ints → 16KB

이 값은 “타일이 최소한 이 정도 규모의 데이터를 반복해서 만질 수 있다”는 감각을 주는 지표임  
(실제로는 접근 순서/캐시라인/세트 충돌 때문에 더 복잡해질 수 있음)

## B가 작을 때 느릴 수 있는 이유
- 타일이 너무 작으면, 같은 캐시라인에서 재사용하는 횟수가 적을 수 있음
- jj/ii 블록 루프 자체가 더 자주 반복되며 오버헤드 비중이 커질 수 있음
- 특히 B=1은 tiling의 장점(재사용)이 거의 없고 오버헤드만 늘기 쉬움

## B가 커질 때 다시 느려질 수 있는 이유
- B가 커질수록 working set이 커짐 → 캐시/TLB 압박이 증가할 수 있음
- 동시에 살아 있어야 하는 캐시라인 수가 늘면서 set 충돌(conflict miss) 가능성도 커질 수 있음
- 결과적으로 “적당한 중간 B”에서 최적이 나오는 구조가 흔함

## lab02 관찰과 연결
- N=4096에서는 B=32가 최적 근처, 64 이상에서 다시 느려지는 경향 관측됨
- N=8192에서는 최적이 여전히 B=32였지만, B>=64 구간에서 성능 저하가 더 크게 관측됨  
→ N이 커질수록 작업집합/페이지 범위가 커져 큰 타일이 더 불리해질 수 있다는 방향으로 해석 가능함

## Intuition: why an optimal B exists
B는 “타일링을 하냐/안 하냐”가 아니라, **재사용(benefit)**과 **비용(cost)**의 균형을 조절하는 손잡이임.

- **B가 너무 작으면**: 블록을 자주 바꾸며 루프 오버헤드가 커지고, 캐시라인/페이지를 충분히 재사용하기 전에 다음 블록으로 넘어가 이득이 작아짐  
- **B를 키우면**: 같은 블록 안에서 같은 근처 데이터가 더 자주 다시 등장해 캐시라인 재사용이 늘고, 블록 루프 반복 횟수도 줄어 오버헤드가 감소함  
- **B가 너무 커지면**: 블록 하나의 working set이 커져 캐시/TLB 압박과 set 충돌/eviction 위험이 증가해 다시 느려질 수 있음  

따라서 보통 **중간 B에서 최적점**이 나타나며, 실험에서 관측된 최적 B는 하드웨어/환경에 따라 달라질 수 있음.

