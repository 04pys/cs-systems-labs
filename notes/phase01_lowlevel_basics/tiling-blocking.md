# Tiling / Blocking (lab02)

## 핵심 한 줄
Tiling(Blocking)은 큰 반복문을 BxB 블록으로 쪼개서 처리해, 한 번 가져온 데이터(캐시라인/페이지)를 짧은 시간 안에 더 많이 재사용하도록 만드는 기법임

## 왜 필요한가 (lab01 → lab02 연결)
`a[i*N + j]`는 row-major 레이아웃임  
- row_major(i outer, j inner): j가 1씩 증가하며 연속 주소(+4B)를 접근 → 공간 지역성↑  
- col_major_like(j outer, i inner): i가 1씩 증가할 때 주소가 +N*4B 점프(stride) → 공간 지역성↓, 충돌/미스↑ 가능

col_major_like는 “연산”이 아니라 “메모리 계층(캐시/TLB)”에서 손해를 보는 구조임

## tiling이 하는 일(미스를 0으로 만드는 기술이 아님)
tiling은 stride 자체를 없애기보다,
1) (i, j) 공간을 작은 창(window)으로 제한하여 working set을 줄이고  
2) 같은 row에서 j를 B개 연속으로 처리하게 만들어 캐시라인 재사용(공간/시간 지역성)을 늘리고  
3) 거듭제곱 stride에서 발생하기 쉬운 cache set 충돌(thrashing)을 완화하는 방향으로 동작함

## lab02 코드에서 tiling 형태
tiled_col(B)는 대략 아래 아이디어임

- 전체를 한 번에 돌지 않고, (ii, jj)로 블록을 선택하고
- 블록 내부에서 i, j를 좁은 범위로만 순회함

이때 중요한 점은 “블록 내부에서 같은 근처 데이터가 반복해서 등장”하도록 만들어 캐시에 남아 있을 확률을 높이는 것임

## 결과를 보는 관점
- B가 너무 작으면: 재사용 이득이 작고 블록 루프 오버헤드가 상대적으로 커질 수 있음
- B가 너무 크면: 블록의 working set이 커져 캐시/TLB 압박 및 충돌 가능성이 커질 수 있음
- 따라서 보통 중간 B에서 최적점이 나타나는 경향임(실제로 B=32가 최적 근처로 관측됨)
