# False Sharing / Cache Coherence 정리 노트

## 1) False Sharing(거짓 공유) 개념
- **정의**: 스레드 간에 “논리적으로는 공유하지 않는” 데이터임에도, **같은 캐시 라인(cache line)** 에 함께 실려 있어서 “공유되는 것처럼” 취급되어 성능 저하가 발생하는 현상임. (https://velog.io/@jinh2352/%EA%B1%B0%EC%A7%93-%EA%B3%B5%EC%9C%A0False-Sharing)  
- **핵심 조건**
  - 서로 다른 스레드가 **서로 다른 변수**를 갱신함  
  - 그런데 그 변수들이 메모리에서 **가까운 주소**에 위치하여 **동일 캐시 라인**에 포함되는 상황임 (velog 링크 동일)  
- **성능 저하 원인(요지)**: 캐시가 다루는 최소 단위는 “변수”가 아니라 **캐시 라인(예: 64B 단위)** 이고, 멀티코어에서는 캐시 일관성 프로토콜이 “한 코어가 해당 라인을 쓰면 다른 코어의 사본을 무효화”시키는 동작을 수행함. 이때 실제로는 서로 다른 변수를 건드리는 중이어도, **같은 라인에 묶여 있으면** 매번 무효화/재획득 트래픽이 발생하여 캐시 미스·버스 트래픽·write-back 오버헤드가 늘어나는 구조임 (velog 링크 동일)

---

## 2) False Sharing 실험에서 자주 보는 형태(C++ 관점)
- 전형적 실험 형태: 두 스레드가 각각 `num1++`, `num2++`를 매우 많이 수행하는 구조이며, 코드 레벨에서는 락이 필요 없어 보이는 “독립 갱신” 형태임 (velog 링크 동일)  
- 그런데 `num1`과 `num2`가 **연이어 선언**되어 인접 주소에 배치되면, 두 값이 **같은 캐시 라인**에 들어갈 확률이 높아지고, 그 결과 false sharing으로 수행 시간이 크게 늘어나는 관찰이 가능함 (velog 링크 동일)  
- 완화 방식 예시(정렬/패딩): 캐시 라인 크기(예: 64B)에 맞춰 변수를 **정렬(alignment)** 하면, 각 변수가 서로 다른 라인에 놓이게 되어 불필요한 무효화 경쟁이 줄어들고 실행 시간이 개선되는 관찰이 소개됨. `alignas(64)` 사용 예시가 제시됨 (velog 링크 동일)

---

## 3) Cache Coherence(캐시 일관성) 개념
- **정의(문제의 출발점)**: 멀티코어에서는 코어마다 **독립적인 캐시**가 존재하여, 같은 메모리 주소의 데이터가 여러 캐시에 동시에 존재할 수 있는 구조임. 이때 한 코어가 값을 바꿨는데 다른 코어가 **캐시에 남아 있는 옛 값**을 읽는 문제가 발생할 수 있어, 이를 막기 위해 “캐시 일관성(cache coherence)”이 필요함. (https://notavoid.tistory.com/139)  
- **문제 시나리오 요지**: 한 스레드가 공유 변수를 갱신했더라도, 다른 스레드가 캐시에 남아 있는 옛 값을 읽는 상황이 가능하다는 설명이 제시됨 (tistory 링크 동일)

---

## 4) Cache Coherence를 달성하는 대표 프로토콜: MESI 요약
- **MESI(Modified/Exclusive/Shared/Invalid)** 는 캐시 라인의 상태를 4가지로 관리하여 일관성을 보장하는 대표 방식임 (tistory 링크 동일)
- 상태 의미
  - **M(Modified)**: 해당 캐시 라인이 수정되어 메모리와 다를 수 있는 상태이며, 다른 캐시에는 동일 데이터가 없다고 보는 상태임 (tistory 링크 동일)
  - **E(Exclusive)**: 해당 캐시에만 존재하지만 메모리와 일치하는 “독점·클린” 상태임 (tistory 링크 동일)
  - **S(Shared)**: 여러 캐시에 동일 데이터가 존재하는 상태이며, **쓰기 시에는 다른 캐시들을 Invalid로 만들 필요**가 있다고 설명됨 (tistory 링크 동일)
  - **I(Invalid)**: 캐시 라인이 무효인 상태이며 접근 시 메모리나 다른 캐시에서 다시 가져와야 하는 상태임 (tistory 링크 동일)
- **false sharing과의 연결점**: “Shared 상태에서 쓰기 시 무효화 필요” 같은 규칙 때문에, 논리적으로는 다른 변수라도 같은 라인에 있으면 **매번 invalidate 유발** → 서로의 진행을 방해하는 ping-pong가 발생하는 구조로 이해 가능함 (velog 링크의 false sharing 설명과 연결되는 지점임)

---

## 5) Bus Snooping(버스 스누핑) 관점 요약
- 일관성 유지 구현 방식 중 하나로 **버스 트랜잭션을 각 캐시 컨트롤러가 모니터링**하여, 읽기/쓰기/무효화 이벤트에 반응하는 메커니즘 설명이 제시됨 (tistory 링크 동일)
- 이 관점에서 false sharing은 “서로 다른 스레드의 쓰기인데도 같은 라인 이벤트로 관측되어 무효화가 반복되는 상황”으로 해석 가능함 (velog 링크 동일)

---

## 6) C++에서의 실전적 대응 체크리스트
- **라인 분리(핵심)**: 서로 다른 스레드가 자주 쓰는 값들을 **서로 다른 cache line**에 두는 설계 필요함(패딩/정렬/구조체 분리 등)임 (velog 링크 동일)
- **정렬/패딩 사용 예시**
  - `alignas(64)`로 변수 또는 구조체를 캐시 라인 경계에 정렬하는 방식 가능함(예시 제시됨)임 (velog 링크 동일)
- **표준 라이브러리 힌트 활용**
  - C++17의 `std::hardware_destructive_interference_size` 같은 값을 활용해 “파괴적 간섭(=false sharing 가능성) 단위”에 맞춰 패딩하는 설계 전략 가능함(플랫폼별 상이 가능성 존재함)임
- **구조 설계 대안**
  - per-thread 로컬 카운터에 누적 후 마지막에 합산(reduction)하는 방식으로 공유 쓰기 자체를 줄이는 설계 가능함
  - 멀티스레드 환경에서 힙 할당자/메모리 배치가 false sharing을 악화시킬 수 있으므로, 특정 환경에서는 할당자 선택이 성능에 영향을 줄 수 있다는 언급 존재함 (velog 링크 동일)

---

## 7) 요약(한 문단)
- false sharing은 “논리적으로는 분리된 데이터”가 “물리적으로 같은 캐시 라인”에 배치되면서, cache coherence 프로토콜의 무효화 규칙(MESI 등) 때문에 불필요한 invalidate 경쟁이 반복되어 성능이 떨어지는 현상임. 따라서 멀티스레드 C++ 코드에서는 **핫(자주 쓰는) 변수들의 cache line 분리(정렬/패딩/구조 분리)** 가 핵심 최적화 포인트가 됨.
- 

## 참고 자료

https://velog.io/@jinh2352/%EA%B1%B0%EC%A7%93-%EA%B3%B5%EC%9C%A0False-Sharing
- false-sharing에 관한 설명.

https://notavoid.tistory.com/139
- cache-coherence에 대한 설명.
  
